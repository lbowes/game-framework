#include "RigidBodyGroup.h"

RigidBodyGroup::RigidBodyGroup(Integrator integrator, MemberUpdateDepth subUpdateDepth) :
	RigidBody(integrator),
	mMemberUpdateDepth(subUpdateDepth)
{ }

void RigidBodyGroup::addBody(RigidBody& member, CoordTransform3D memberToGroup) {
	bool reusedSlot = false;
	
	//Before adding anything else to the vector we want to check whether or not a space has been vacated by a previous now-disconnected body
	for (int i = 0; i < mMembers.size(); i++) {
		if (mMembers[i].mConnected == false) {
			mMembers[i] = RBGroupMember(member, memberToGroup);
			updateMemberState(mMembers[i]);
			reusedSlot = true;
			break;
		}
	}
	
	//But if we've not been able to find a spare space, then create a new one
	if (!reusedSlot) {
		mMembers.push_back(RBGroupMember(member, memberToGroup));
		updateMemberState(mMembers.back());
	}

	updateCombinedMass_local();
	updateCombinedInertia_local();
}

void RigidBodyGroup::update(double t, double dt) {
	//If there is one body connected to the group, it must be classed as disconnected (there is no group anymore)
	if (isFullyFragmented()) {
		for (RBGroupMember& m : mMembers)
			m.disconnect();
	}
	else {
		//Use the result of the integration to manually provide the state of each of the connected subs (reposition, reorient etc)
		updateAllMemberStates();
		
		//Update the combined properties of the group
		updateCombinedMass_local();
		updateCombinedInertia_local();

		//Integrate the group state
		integrate(t, dt);
	}
}

void RigidBodyGroup::updateCombinedMass_local() {
	Mass combined;

	for (RBGroupMember& m : mMembers) {
		if (m.mConnected) {
			const Mass& memberMass_sub = m.mRigidBody->mState.getMass_local();
			
			glm::dvec3 memberCoM_group = m.mMemberToGroup.toParentSpace(memberMass_sub.getCentre());
			
			combined += Mass(memberMass_sub.getValue(), memberCoM_group);
		}
	}

	mState.setMass_local(combined);
}

void RigidBodyGroup::updateCombinedInertia_local() {
	//Use the relative transformations of the sub bodies to calculate a group inertia tensor
	//1. Rotate the inertia tensor of each sub into group space
	//2. Use the parallel axis theorem to translate the new inertia from the sub's centre of mass, to the group's centre of mass
	//3. Add this to the total

	InertiaTensor combinedInertia;

	for (RBGroupMember& m : mMembers) {
		if (m.mConnected) {
			const State& memberState = m.mRigidBody->mState;
			
			InertiaTensor rotatedMember = memberState.getInertiaTensor_local().afterRotation(m.mMemberToGroup.getLocalToParent_rotation());
			
			combinedInertia += InertiaTensor::parallelAxis(
				rotatedMember,
				memberState.getMass_local().getValue(),
				mState.getMass_local().getCentre() - m.mMemberToGroup.toParentSpace(memberState.getMass_local().getCentre())
			);
		}
	}
	
	mState.setInertiaTensor_local(combinedInertia);
}

void RigidBodyGroup::addForces(const State& state, double t) 
	//Adds all the forces generated by subs to the total, for use by the group.
{
	for (RBGroupMember& m : mMembers) {
		if (m.mConnected) {
			for (const Force_world& force_world : m.mRigidBody->getForces_world())
				addForce({ force_world.mForce_world, m.mMemberToGroup.toParentSpace(force_world.mApplicationPoint_local) });
		}
	}
}

void RigidBodyGroup::addTorques(const State& state, double t) { 
	//TODO: Apply torques added to sub bodies
}

void RigidBodyGroup::updateAllMemberStates() 
	//This function must be called to update the members when the group's state has changed.
{
	for (RBGroupMember& m : mMembers) {
		if (m.mConnected)
			updateMemberState(m);
	}
}

void RigidBodyGroup::updateMemberState(RBGroupMember& toUpdate) {
	using namespace glm;

	State& memberState = toUpdate.mRigidBody->mState;

	//Regardless of update depth, all sub bodies must be given a position_world and orientation_world each update
	//Position
	memberState.setPosition_world(
		mState.getObjectSpace().toParentSpace(
			toUpdate.mMemberToGroup.toParentSpace()
		)
	);

	//Orientation
	memberState.setOrientation_world(
		mState.getObjectSpace().toParentSpace_rotation(
			glm::toQuat(toUpdate.mMemberToGroup.getLocalToParent_rotation())
		)
	);

	//If we're only performing a shallow update, then the sub bodies won't be given their full state until they disconnect,
	if (mMemberUpdateDepth == MemberUpdateDepth::shallow) {
		memberState.setVelocity_world(glm::dvec3(0.0));
		memberState.setAngularVelocity_world(glm::dvec3(0.0));
	}
	//but if this is a deep update, then the entire state of the sub bodies must be calculated each update.
	else if (mMemberUpdateDepth == MemberUpdateDepth::deep) {
		//Linear velocity
		memberState.setVelocity_world(
			mState.velocityAtLocalPoint_world(
				toUpdate.mMemberToGroup.toParentSpace(
					memberState.getMass_local().getCentre()
				)
			)
		);

		//Angular velocity
		memberState.setAngularVelocity_world(mState.getAngularVelocity_world());
	}
}

bool RigidBodyGroup::isFullyFragmented() {
	unsigned mNumConnections = 0;

	for (RBGroupMember& m : mMembers)
		mNumConnections += m.mConnected;

	return mNumConnections < 2;
}